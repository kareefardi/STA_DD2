  <!DOCTYPE html>
  <html>

  <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script src="/home/agalal/Downloads/jquery-3.2.1.min.js"></script>
  <script src="/home/agalal/Downloads/DDproj/graphlib.min.js"></script>

  <script>
/*Uncomment 160-163 to display the paths*/

  var request = new XMLHttpRequest();
  request.open("GET", "/home/agalal/Downloads/DDproj/Testing/des7.json", false);
  request.send(null);
  var my_JSON_object = JSON.parse(request.responseText);

 var M_name;
 var Module;
 for (M_name in my_JSON_object["modules"])
     Module = my_JSON_object["modules"][M_name];

 var g = new graphlib.Graph();
 var ports, p;
 var bits = [];
 var names = [];
 var index = 0;
 var maxBitValue;        //maximum value given to i/o
 var lastInputBit;

 var inputTransitionMap = [];
 for(var i = 0; i < 200; i++)
    inputTransitionMap[i] = [];
 var indexMap = 0;
 for (p in Module["ports"])
 {
   ports = Module["ports"][p];
   names[index] = p;             //store all the ports names

   var j;
   for (j in ports["bits"])
       bits[index] = ports["bits"][j];     //store all the ports bits
   maxBitValue = bits[index];              //to get maximum bit used for inputs
   if(Module["ports"][p]["direction"] == "input")
     lastInputBit = bits[index];

   //rst,en won't be taken into paths so name is defaultValue
   //but others will have their direction normally

   if(p != "en" && p != "rst")
       g.setNode(bits[index],Module["ports"][p]["direction"]); //TODO
   else
       g.setNode(bits[index],"default"); //TODO
   inputTransitionMap[indexMap++].push(bits[index++]);
 }


 for(p in Module["cells"])   //adding the cells as nodes to the graph
   {g.setNode(p,Module["cells"][p]["type"]); inputTransitionMap[indexMap++].push(p);}
 g.setNode("temp","temp"); //node to hold all not-unknown-yet edges

 //Adding edges
 var toTemp = [];
 var fromTemp = [];
 index = 0; index2 = 0;
 for(p in Module["cells"])
 {
   for(it in Module["cells"][p]["connections"])
   {
     var found = false;
     var pathFound = Module["cells"][p]["connections"][it];
     if(it == "Y" || it == "Q")  //output to the gate is a wire
     {
       if(pathFound >= lastInputBit+1 && pathFound <= maxBitValue)     //if output to gate is output to circuit
         {g.setEdge(p,pathFound);}// console.log(1);}
       else {
         for(var element in fromTemp)
         {
           if(Number(g.edge("temp",fromTemp[element])) == Number(pathFound))
           {
             g.setEdge(p,fromTemp[element]);
             found = true;
           }
         }
         if(!found)
         {g.setEdge(p,"temp",pathFound);
         toTemp[index++] = p;}
       }
     }else {                  //input to gate
       if(pathFound <= maxBitValue) //input to gate is input to whole circuit
         {g.setEdge(pathFound,p);}//console.log(1);}
       else {                //input to the gate is a wire
         for(var element in toTemp)
         {
           if(Number(g.edge(toTemp[element],"temp")) == Number(pathFound))
           {
             g.setEdge(toTemp[element],p);
             found = true;
           }
         }
         if(!found)
         {
           g.setEdge("temp",p,pathFound);
           fromTemp[index2++]=p;
         }
       }
     }
   }
 }
g.removeNode("temp");
var nodes = g.nodes();
for(var node in nodes)
{
    if(g.node(nodes[node]) == "output")
    {
      var outEdges = g.outEdges(nodes[node]);
      for(var edge in outEdges)
        g.removeEdge(outEdges[edge]["v"],outEdges[edge]["w"]);
    }
}

   var paths = [];
   var path_type = [];
   for ( var k = 0; k < 100; k++) // iniaize path arrays
   {
     paths[k] = [];
   }
   var ii = 0;

   for(var ee = 0; ee < nodes.length; ee++)
   {
     if (String(g.node(nodes[ee])) == "input" || String(g.node(nodes[ee])) == "DFFPOSX1")
       {
         paths[ii].push(nodes[ee]);
         dfs(nodes[ee]);
       }
    }
    for (var kk = 0; kk < ii; kk++)
    {
      var first, last;

      first = paths[kk][0];
      last = paths[kk][paths[kk].length - 1];

      var ftype, ltype;

      ftype = g.node(first);
      ltype = g.node(last);

      if (ftype == "input" && ltype == "output")
        path_type[kk] = "input-output";
      else
      if (ftype == "DFFPOSX1" && ltype == "DFFPOSX1")
        path_type[kk] = "reg-reg";
      else
      if (ftype == "DFFPOSX1" && ltype == "output")
        path_type[kk] = "reg-output";
     if (ftype == "input" && ltype == "DFFPOSX1")
        path_type[kk] = "input-reg";

       //console.log(path_type[kk]);
        //for(var i in paths[kk])
          //console.log(paths[kk][i]);
        //console.log('\n\n');
    }

   function dfs(current)
   {
     var adj_nodes = g.outEdges(current);

     if(adj_nodes.length != 0)
     {
       for (var e in adj_nodes)
       {
         var target = g.node(adj_nodes[e]["w"])
         if(!(target == "DFFPOSX1" || target == "output"))
           {
             paths[ii].push(adj_nodes[e]["w"]);
             dfs(adj_nodes[e]["w"]);
           }
           else {   //if target is DFF or output
             paths[ii].push(adj_nodes[e]["w"]);
             ii++;
             for(var i in paths[ii-1])
                  paths[ii].push(paths[ii-1][i]);
            if(paths[ii].length != 0)
              paths[ii].pop();
             break;
           }
       }
            if(paths[ii].length != 0)
                {paths[ii].pop();}
     }
   }

   request = new XMLHttpRequest();
   request.open("GET", "/home/agalal/Downloads/DDproj/osu035.json", false);
   request.send(null);
   var osu_JSON_object = JSON.parse(request.responseText);
   var tempTime = 0.1;

  //Assuming trash input transition time for now

  var node, allNodes = g.nodes();
  for(node in allNodes)
  {
    if(g.node(node) == "input" || g.node(node) == "default")
    {
      inputTransitionMap[Number(node) - 2].push(tempTime);
      tempTime += 0.1;
    }
  }

  for(node in allNodes)
  {
    if(g.node(node) == "input" || g.node(node) == "default")
    {
      getInputTransition(node);
      //console.log(node);
    }
  }
  console.log(inputTransitionMap);

  function getInputTransition(node)
  {
    var adjEdges = g.outEdges(node);
    var indexEdge;
    for(indexEdge in adjEdges)
    {
      var target = adjEdges[indexEdge]["w"];
      var shouldBeChecked = check(target);
      if(shouldBeChecked == true)
      {
        var i = searchMap(target);
        var times = [];
        var inEdges = g.inEdges(target);
        var edgeIndex;
        for(edgeIndex in inEdges)
        {
          var parent = inEdges[edgeIndex]["v"];
          var j = searchMap(parent);
          times.push(inputTransitionMap[j][1]);
        }
        var min = -1000;
        for (var ind in times)
          if(times[ind] > min)
            min = times[ind];
        inputTransitionMap[i].push(min);
        getInputTransition(target);
      }
    }
  }

  function check(node)
  {
    var i = searchMap(node);
    if(inputTransitionMap[i].length == 2) return false;  //checking if it was previously done
    else
    {
      var inEdges = g.inEdges(node);
      var edgeIndex;
      for(edgeIndex in inEdges)
      {
        var target = inEdges[edgeIndex]["v"];
        var i = searchMap(target);
        if(inputTransitionMap[i].length != 2) return false;
      }
      return true;  // all its inputs already have their transition time
    }
    return false;
  }

  function searchMap(node)
  {
    for(var i = 0; i < g.nodeCount(); i++)
    {
      if(inputTransitionMap[i][0] == node)
        return i;
    }
    return -1;
  }

   </script>
   </html>
